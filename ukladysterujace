/*
 * Tomasz Kowalczyk
 * Łukasz Zawistowicz
 */


//#define F_CPU 16000000UL

#include <avr/io.h> // zawiera on definicje, odpowiednie dla naszego mikrokontrolera.

#include <util/delay.h>

#include <stdint.h>

#include <avr/interrupt.h>

//#define sbi(x,y) x |= _BV(y) //set bit - using bitwise OR operator
//
//#define cbi(x,y) x &= ~(_BV(y)) //clear bit - using bitwise AND operator
//
//#define tbi(x,y) x ^= _BV(y) //toggle bit - using bitwise XOR operator
//
//#define is_high(x,y) (x & _BV(y) == _BV(y)) //check if the y'th bit of register 'x' is high ... test if its AND with 1 is 1
//
//#define is_low(x,y) ((x & _BV(y)) == 0) //check if the input pin is low


#define sbi(x,y) x |= _BV(y) //set bit
#define cbi(x,y) x &= ~(_BV(y)) //clear bit
#define tbi(x,y) x ^= _BV(y) //toggle bit
#define is_high(x,y) ((x & _BV(y)) == _BV(y))

#define czekaj(czas) for(int i=0;i<(czas);i++) _delay_us(1);



// Funkcja testowa do wykonywania testów
void test(){
			DDRA = 0xff;  								// Do rejestru DDRA wpisujemy wartośc 11111111 aby wszystkie piny Porty były wyjściami
			PORTA = 0xff;    					        // wyłaczenie wszystkich diod (Katoda) 0b11111111;

			while(1){

				uint8_t i, liczba=3;
				for (i=0; i<8; i++){
					PORTA = ~liczba;					// operator negacji. Do portu przekazujemy odpowiednio 111111110, 11111101
					liczba = liczba * 2;				// 1,2,4,8,16,32.64,128   //liczba = 1 zapalanie diody w kolejności / liczba = 2 zapalanie dwóch diod

					_delay_ms(5000);

				}

			PORTA = 0xff;
			_delay_ms(5000);

			}
}



/* Zadanie 1: chcemy zmusić naszą diodę do mrugania, co jedną sekundę, czyli z częstotliwością 1Hz
 * chcemy zmusic nóżkę mikrokontrolera by przyjmowała stan niski lub wysoki
 * Rejestry są to komórki w specjalnej pamięci do której procesor ma bezpośredni, szybki dostęp
 * Wszystkie nóżki na samym początku, po włączeniu zasilania są domyślnie wejściami, odpowiada za to rejestr "DDRx" (gdzie x to literka portu)
 * Aby nasze diody stały się wyjściami, musimy zapisać do rejestru "DDRB" wartość 2 (czyli binarnie 00000010). Stan logiczny portu kontroluje rejestr "PORTx"
 * (gdzie x to literka portu)
 *
 *
 *
 * Każdy port posiada 3 własne rejestry:
    Rejestr danych (PORTx) odpowiada za stany logiczne na porcie (wysoki lub niski), kiedy pin jest ustawiony jako wyjście, w przeciwnym wypadku - kiedy port jest wejściem, rejestr ten włącza lub wyłącza rezystor podciągający dla pinu.
    Rejestr kierunku (DDRx) odpowiada za ustawienie pinu jako wejścia lub jako wyjścia. Domyślnie po resecie wszystkie piny są wejściami, aby ustawić wybrany jako wyjście, należy ustawić odpowiedni bit rejestru DDRx.
    Dane pinów wejściowych (PINx) jest to rejestr, który można odczytać, aby sprawdzić stan logiczny na pinie, kiedy ten jest wejściem. W kodzie można to zrobić przy pomocy instrukcji warunkowej if()
 * */



void mruganie_dioda(){


	/* Konfiguracja odpowiednich pinów jako wyjścia
	 * POTRB |= (1<<PB1);   						ustawiamy wybrany bit na "1" np. PB0 -> zgaszamy bez zmiany wartości pozostałych
	 * PORTB &= ~(1<<PB2); 							ustawiamy wybrany bit na "0" np. PB0 -> zapalony bez zmiany wartości pozostałych
	 * PORTD |= (1<<5)|(1<<)|(1<<7); 				ustawia bity 5, 6 i 7, portu PORTD
	 * PORTD &= ~(1<<2)|(1<<3); 					zeruje bity 2 i 3, portu PORTD
     * PORTD ^= (1<<1)|(1<<2); 						odwraca bity 1 i 2, portu PORTD
     * PORTD & PD2; 								zwraca wartość 1, jeżeli pin 2 portu PORTD jest ustawiony (ma wartość 1)
	 */



		DDRA = 0xff;  								// Do rejestru DDRA wpisujemy wartośc 11111111 aby wszystkie piny Porty były wyjściami
		PORTA = 0xff;    					        // wyłaczenie wszystkich diod (Katoda) 0b11111111;

		while(1){


			PORTA &= ~(1<<PA0);					    // zapalenie diody 0b11111110
			_delay_ms(1000);
			PORTA |= (1<<PA0);						// zgaszenie diody 0b11111111
			_delay_ms(1000);


		}
	}




/*
 * Zadanie 2. Zaświecenie diod LED po przyciśnięciu przycisku PIN0
 */
void button_led(){

	DDRB  =  0b00000000;			// Ustawienie PB0-7 na wejście
	PORTB =  0b00000001; 	        // PB0 zmieniamy wartośc logiczna
	DDRA  =  0b11111111; 			// wyjscie dla wszystkich z PA

	while(1){

		if(PINB & 0b00000001){ 			// jesli pin B jest przycisniety
			PORTA = 0b11111111;			// ustaw PA0-PA7 na 1 / zaswiecenie doiod LED
		}

		else{
			PORTA = 0b00000000; 		// inaczej zgas wszystkie diody
		}

	}
}





/*
 * Zadanie 3. Mruganie diodami w formie węża
 */
void snake(){

	DDRA = 0xff;        // PA0-7 wyjscie
	PORTA = 0xff;
	const int size = 8;

	char arr[size];

	arr[0] = 0b00000001;
	arr[1] = 0b00000010;
	arr[2] = 0b00000100;
	arr[3] = 0b00001000;
	arr[4] = 0b00010000;
	arr[5] = 0b00100000;
	arr[6] = 0b01000000;
	arr[7] = 0b10000000;

	int it = 0;
	int val = 1;

	while(1){

		//PORTA |= (1<<it);
		PORTA = arr[it];
		_delay_ms(1000);

			if(it == size-1){
				val = -1;
			}else if(it == 0){
				val = 1;
			}

		it += val;
	}
}






/*
 * Zadanie 4 Przygasanie światełek
 */

void przygasanie_led(){

	DDRA = 0xff;  								// Do rejestru DDRA wpisujemy wartośc 11111111 aby wszystkie piny Porty były wyjściami
	PORTA = 0xff;    					        // wyłaczenie wszystkich diod (Katoda) 0b11111111;

	int t = 1000;
	int x = 0;
	int minus = 1;

	while(1){

		PORTA = 0b11111111;    					// wyłaczenie wszystkich diod (Katoda)
		czekaj(t - x);							// // 1000, 999, 998, 997 ... 0, 1, 2, 3, ,..., 1000
		PORTA = 0b00000000;
		czekaj(x);								// 0, 1, 2, 3, ... 1000, 999, 998 , ..., 0

		if(x == 1000){
			minus = -1;
		}

		else if(x == 0){
			minus = 1;
		}

		x += minus;

	}
}






/*
 * Fala światełek
 */




void rozjasnienie(liczba, t, i){
	int x=0, minus=1, k=0;
	for (int j=0; j<t; j++){

						PORTA  = 0b11111111; // wyłaczenie
						czekaj(t - x);
						PORTA = ~liczba; // właczenie
						czekaj(x);

						x = x + minus;

					}
	PORTA = ~liczba;
}

void przygasniecie(liczba, t, i){
	int x=t, minus=1;
	for (int j=0; j<t; j++){
						PORTA = 0b11111111;
						czekaj(t - x);
						PORTA = ~liczba;
						czekaj(x);

						x = x - minus;

					}
	PORTA = ~liczba;
}





void wave(){

	    DDRA = 0xff;  								// Do rejestru DDRA wpisujemy wartośc 11111111 aby wszystkie piny Porty były wyjściami
		PORTA = 0x00;    					        // wyłaczenie wszystkich diod (Katoda) 0b11111111;



		while(1){

					uint8_t i, liczba=1;

			for (i=0; i<8; i++){


				rozjasnienie(liczba, 1000, i);
				rozjasnienie(liczba * 2, 1000);
				przygasniecie(liczba, 1000);
				przygasniecie(liczba * 2, 1000, i);
				liczba = liczba * 2;
				//t = t - 100;
				//czekaj(500);
			}




		}

}

/* Zadania zestaw 2 */


// Zadanie 2.1

/* Przerwanie (ang. interrupt) sygnał powodujący zmianę przepływu sterowania, niezależnie od aktualnie 
   wykonywanego programu. Pojawienie się przerwania powoduje wstrzymanie aktualnie wykonywanego programu i wykonanie przez procesor kodu procedury. 
   Na końcu wydaje instrukcję powrotu z przerwania, która powoduje powrót do programu realizowanego przed przerwaniem.
*/

// dodawanie binarne za pomoca LED
ISR(INT0_vect){
	static uint8_t a = 0;
	++a;
	uint8_t b = 1;
	b &= PORTA;
	PORTA = ~(a*2);
	PORTA |= b;

}


void setup_interrupt(){
	DDRA = 0xff;							// DDRA - wyjscie
	DDRD  =  0b00000000;					// DDRD - wejscie
	PORTD =  0b00000100; 	        		// PD2
	MCUCR |= (1 << ISC01) | (0 << ISC00);   // MCUR- MCU Control Register
	GICR |= (1 << INT0);					// Int0 = PD2 posiada konfigurowalny sposób wyzwalania
											// GICR General interrupt control register
	sei();
}


/*
 * Miganie pierwsza dioda
 */
void blink(){
	        DDRA = 0xff;  								// Do rejestru DDRA wpisujemy wartośc 11111111 aby wszystkie piny Porty były wyjściami
			PORTA = 0xff;    					        // wyłaczenie wszystkich diod (Katoda) 0b11111111;

			while(1){
				PORTA &= ~(1<<PA0);					    // zapalenie diody 0b11111110
				_delay_ms(1000);
				PORTA |= (1<<PA0);						// zgaszenie diody 0b11111111
				_delay_ms(1000);
			}
}

// Koniec zadania 2.1



// Zadanie 2.2
// Rozjaśnianie i przyciemnianie diody dwa przyciski

void setup(){
	DDRD = 0x00;
	DDRB = 0xff;
	PORTD = 3;
	TCCR0 = (1 << WGM01) | (1 << WGM00) | (1 << COM01) | (1 << CS01);
	TCNT0 = 0;
	OCR0 = 0;
}

int zad22(void){
	setup();
    while(1){
		if(!(PIND & 1)){
			OCR0++;
		}	

		if(!(PIND & 2)){
			OCR0--;
		}
		czekaj(500);
	}
}

int main(void){

//wave();
//przygasanie_led();
//mruganie_dioda();
//button_led();
//snake();
//test();


/* Uruchomienie zadania 2.1
 *
 *  setup_interrupt();
 *	blink();
 */

/* Uruchomienie zadania 2.2
 *
 *  zad22();
 *
 */
	zad22();

}

